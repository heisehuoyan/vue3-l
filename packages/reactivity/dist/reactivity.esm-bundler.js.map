{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/basehandlers.ts","../src/reactive.ts"],"sourcesContent":["export const isObject = (value) => typeof value == \"object\" && value != null;\nexport const extend = Object.assign; // 合并\n","// 我们需要让这个effect变成响应的effect，可以做到数据变化的时候执行\nexport function effect(fn, options: any = {}) {\n  const effect = createReativitveEffect(fn, options);\n\n  if (!options.lazy) {\n    effect(fn, options); //响应式的effect 默认先执行一边\n  }\n\n  return effect;\n}\n\nlet uid = 0; // 标示每个effect\nlet activeEffect; //存储当前的effect\nconst effectStack = [];\nfunction createReativitveEffect(fn, options) {\n  const effect = function reativitveEffect(fn, options) {\n    if (!effectStack.includes(effect)) {\n      // 保证effect没有加入到effectStack中，解决特殊情况2\n      try {\n        // 函数执行时可能发生异常\n        effectStack.push(effect); // 入栈\n        activeEffect = effect;\n        return fn(); // 默认第一次执行,函数执行时取值，会执行get方法，让属性和effect产生关联，收集effects\n      } finally {\n        effectStack.pop(); // 出栈，\n        activeEffect = effectStack[effectStack.length - 1]; //即每次取数组最后一个\n      }\n    }\n  };\n  effect.id = uid++; // 制作一个effect标识，用于区分effect\n  effect.isEffect = true; // 用户标识这个是响应式effect\n  effect.raw = fn; // 保存effect对应原本函数\n  effect.options = options; // 保存选项\n  return effect;\n}\n\nconst targetMap = new WeakMap(); // 映射表\n\n// 让某个对象中的属性收集当前他对应的effect函数\nexport function track(target, type, key) {\n  //activeEffect; // 可以拿到当前的effect\n  //activeEffect 并不是收集所有，activeEffect有才收集\n  if (activeEffect === undefined) {\n    return;\n  }\n  // activeEffect有值，说明此属性在effect中使用，不在effect中使用的不需要收集依赖\n  let depsMap = targetMap.get(target); // 取值，取到的是一个map，即value:name=>[effect,effect]\n  if (!depsMap) {\n    // 如果某个对象不存在这个值\n    targetMap.set(target, (depsMap = new Map())); // 没有就把value往里放\n  }\n  let dep = depsMap.get(key); // 取值，即{name=>set}，检查map中有没有name属性，即重复的属性，一个effect可能对应多个属性\n  if (!dep) {\n    depsMap.set(key, (dep = new Set())); // 没有，则增加\n  }\n  if (!dep.has(activeEffect)) {\n    // 如果set中没有当前的effect，则加进去\n    dep.add(activeEffect);\n  }\n  debugger;\n  console.log(targetMap);\n}\n\n//{name:'lcj',age:12} name->name可能对应两个effect，即[effect,effect]\n// 某个对象中某个属性对应的effect\n// 对象作为key weakMap\n//weakMap=>key:{name:'lcj',age:12} ，value:name=>[effect,effect]即也是一个map,map中的key是那么，值是一个set，{name=>set}\n\n// 特殊情况3\n// effect(()=>{ // 一个effect可能对应多个属性\n//   state.name  state.name  state.name\n// })\n\n//特殊情况1,,,,函数调用是一个栈型结构：effectStack，函数执行前入栈，执行完之后出栈    ：保证每个属性收集的effect是对的\n// effect(()=>{\n//   state.name='33', ->effect1\n//   effect(()=>{->effect2\n//     StaticRange.arguments.n=10\n//   }),\n//   state.ad=4444 ->effect2，但是其实是effect1\n// })\n\n// 情况2 ，++后持续执行effect，不停的刷新，，，， 思路：在栈中判断是否已经存在了该effect\n// effect(()=>{\n// state.count++\n// })\n","import { extend, isObject } from \"@vue/shared/src\";\nimport { reacdonly, reactive } from \"./reactive\";\nimport { track } from \"./effect\";\n\n// 实现拦截方法\n// 是不是仅读，仅读的属性set报异常\n// 是不是深度的\n\nfunction createGetter(isReadonly = false, isShallow = false) {\n  // 取值的时候通过代理对象去取：let proxy =reactive(),通过proxy去取，取值触发get方法\n  // receiver 代理对象本身 //其实就是proxy\n  return function get(target, key, receiver) {\n    //proxy +Reflect  Reflect好处：后续object上的方法会被迁移到Reflect ，比如 object.getProptypeof\n    // 以前target[key]=value 方式设置值可能会失败，并不会报异常，也没有返回值标志，但Reflect可以，Reflect方法具备返回值\n    //Reflect（es6）可以不使用proxy，\n    const res = Reflect.get(target, key, receiver); // 等价于target[key] // 固定的api ，反射，去proxy取值，它就吧原来的目标的值反射回去\n\n    if (!isReadonly) {\n      track(target, TrackOpType.GET, key); // 执行effect时会取值，收集effect\n      // 不是仅读的，收集依赖，等数据变化后更新视图\n    }\n\n    if (isShallow) {\n      //浅的，直接返回，不用做处理，浅的只代理第一层\n      return res;\n    }\n\n    if (isObject(res)) {\n      //vue2是一上来递归，vue3是当取值的时候进行代理，vue3的代理模式是懒代理\n      return isReadonly ? reacdonly(res) : reactive(res); // 递归\n    }\n    return res;\n  };\n} // 拦截获取功能\n\nfunction createSetter(isShallow = false) {\n  // 设置值时触发set方法\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver); // 等价于 target[key] =value\n\n    // 当数据更新时，通知对应属性的effect重新执行\n    //todo\n    return result;\n  };\n} // 拦截设置功能\n\nconst get = createGetter();\nconst shallowGet = createGetter(false, true);\nconst readonlyGet = createGetter(true);\nconst shallowReadonlyGet = createGetter(true, true);\n\nconst set = createSetter();\nconst shallowSet = createSetter(true);\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\n\nexport const shallowReativeHandlers = {\n  get: shallowGet,\n  set: shallowSet,\n};\n\nlet readonlyObj = {\n  set: (target, key) => {\n    console.warn(`set on key ${key} failed`);\n    return true;\n  },\n};\n\nexport const reacdonlyHandlers = extend(\n  {\n    get: readonlyGet,\n  },\n  readonlyObj\n);\nexport const shallowReacdonlyhandlers = extend(\n  {\n    get: shallowReadonlyGet,\n  },\n  readonlyObj\n);\n","import { isObject } from \"@vue/shared/src\";\nimport {\n  mutableHandlers,\n  shallowReativeHandlers,\n  reacdonlyHandlers,\n  shallowReacdonlyhandlers,\n} from \"./basehandlers\";\n\nexport function reactive(target) {\n  return createReativeObject(target, false, mutableHandlers);\n}\nexport function shallowReactive(target) {\n  return createReativeObject(target, false, shallowReativeHandlers);\n}\nexport function reacdonly(target) {\n  return createReativeObject(target, true, reacdonlyHandlers);\n}\nexport function shallowReacdonly(target) {\n  return createReativeObject(target, true, shallowReacdonlyhandlers);\n}\n\n// 创建两个存储空间\nconst reactiveMap = new WeakMap(); // 会自动回收，不会造成内存泄漏，存储key只能是对象\nconst reacdonlyMap = new WeakMap();\n\n// 拦截的方式不同\n// 是不是仅读，是不是深度，柯里化 new Proxy最核心是的就是拦截数据的读取和更改   get set\n\n/**\n *\n * @param target // 目标对象\n * @param isReadonly //是否仅读\n * @param baseHandles //拦截函数\n */\nfunction createReativeObject(target, isReadonly, baseHandles) {\n  // 如果目标不是对象，没法拦截，reactive这个api只能拦截对象类型\n  if (!isObject(target)) return target;\n\n  // 如果某个对象已经被代理过了，就不要再代理了 。。 代理了就直接吧代理过的结果直接返回，可能一个对象被代理深度，又被仅读代理\n\n  const proxyMap = isReadonly ? reacdonlyMap : reactiveMap; //代理的映射表\n\n  const exitProxy = proxyMap.get(target); //判断是否被代理\n  if (exitProxy) return exitProxy; // 如果已经被代理了，就直接返回结果\n\n  const proxy = new Proxy(target, baseHandles);\n  proxyMap.set(target, proxy); // 缓存proxy,表示target被代理了，：将代理对象和对应的结果缓存起来\n\n  return proxy;\n}\n"],"names":[],"mappings":"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"}